---
name: Canonical Labels API - Ground Truth Management
status: open
created: 2026-02-06T16:44:03Z
updated: 2026-02-06T16:44:03Z
github: [Will be updated when synced to GitHub]
depends_on: [001]
parallel: true
conflicts_with: []
---

# Task: Canonical Labels API - Ground Truth Management

## Description

Build the backend API and Pydantic models for Canonical Label management. Canonical Labels are the core innovation enabling "label once, reuse everywhere". This task implements the composite key `(sheet_id, item_ref, label_type)`, version tracking, and governance constraints (allowed_uses, prohibited_uses).

**Critical:** This is the differentiating feature of the platform.

## Acceptance Criteria

- [ ] Pydantic model `CanonicalLabel` with composite key fields
- [ ] API endpoints: POST, GET (list), GET (detail), PUT, DELETE for `/api/v1/canonical-labels`
- [ ] Query by composite key `(sheet_id, item_ref, label_type)`
- [ ] Prevent duplicate labels for same composite key (upsert behavior)
- [ ] Support label versioning when updating existing labels
- [ ] Support governance fields: `allowed_uses`, `prohibited_uses`, `usage_reason`, `data_classification`
- [ ] Bulk import endpoint for batch labeling
- [ ] Query endpoint: "Get all labels for this Sheet"
- [ ] Query endpoint: "Get all labels for this item_ref across all Sheets"

## Technical Details

**Pydantic Models:**
```python
# backend/app/models/canonical_label.py
class CanonicalLabel(BaseModel):
    id: str = Field(default_factory=lambda: f"cl-{uuid4()}")
    sheet_id: str
    item_ref: str  # e.g., "invoice_042.pdf", "row_123"
    label_type: str  # e.g., "entity_extraction", "classification"
    label_data: Dict  # JSON variant - structure depends on label_type
    confidence: Literal["high", "medium", "low"] = "high"
    notes: Optional[str] = None
    allowed_uses: List[str] = ["training", "validation", "few_shot", "testing", "evaluation"]
    prohibited_uses: List[str] = []
    usage_reason: Optional[str] = None
    data_classification: Literal["public", "internal", "confidential", "restricted"] = "internal"
    labeled_by: str
    labeled_at: datetime
    last_modified_by: Optional[str] = None
    last_modified_at: Optional[datetime] = None
    version: int = 1
    created_at: datetime
```

**API Endpoints:**
```python
# backend/app/api/v1/canonical_labels.py
@router.post("/canonical-labels", response_model=CanonicalLabel)
async def create_canonical_label(label: CanonicalLabelCreate, db: DatabricksSession)

@router.get("/canonical-labels", response_model=List[CanonicalLabel])
async def list_canonical_labels(
    sheet_id: Optional[str] = None,
    label_type: Optional[str] = None,
    item_ref: Optional[str] = None,
    db: DatabricksSession = Depends()
)

@router.get("/canonical-labels/{label_id}", response_model=CanonicalLabel)
async def get_canonical_label(label_id: str, db: DatabricksSession)

@router.get("/canonical-labels/lookup")
async def lookup_by_composite_key(
    sheet_id: str,
    item_ref: str,
    label_type: str,
    db: DatabricksSession = Depends()
)

@router.put("/canonical-labels/{label_id}", response_model=CanonicalLabel)
async def update_canonical_label(
    label_id: str,
    label: CanonicalLabelUpdate,
    db: DatabricksSession
)

@router.post("/canonical-labels/bulk-import")
async def bulk_import_labels(labels: List[CanonicalLabelCreate], db: DatabricksSession)
```

**Service Layer:**
```python
# backend/app/services/canonical_label_service.py
class CanonicalLabelService:
    def get_by_composite_key(self, sheet_id: str, item_ref: str, label_type: str) -> Optional[CanonicalLabel]
    def upsert_label(self, label: CanonicalLabel) -> CanonicalLabel  # Update if exists, insert if not
    def increment_version(self, label: CanonicalLabel) -> CanonicalLabel
    def get_labels_for_sheet(self, sheet_id: str) -> List[CanonicalLabel]
    def get_labels_for_item(self, item_ref: str) -> List[CanonicalLabel]
```

**Files to Create/Modify:**
```
backend/app/
├── models/canonical_label.py
├── api/v1/canonical_labels.py
├── services/canonical_label_service.py
└── main.py (register router)
```

**Critical Implementation Notes:**
- Use `MERGE INTO` for upserts based on composite key
- Increment version number on updates
- Store previous version in `label_versions` table (future)
- Validate `sheet_id` references existing Sheet
- Validate `label_type` matches a known type (enum or template label_types)

## Dependencies

- [ ] Task 001 (Delta tables created with composite key constraint)
- [ ] Task 002 (Sheet API for validating sheet_id references)

## Effort Estimate

- Size: L
- Hours: 16-20 hours
- Parallel: true (can run alongside Tasks 002-003)

## Definition of Done

- [ ] All endpoints implemented and working
- [ ] Composite key lookup working (sub-100ms query time)
- [ ] Upsert behavior prevents duplicate labels
- [ ] Version tracking increments on updates
- [ ] Bulk import can load 100+ labels in <10 seconds
- [ ] Governance fields (allowed_uses, prohibited_uses) properly stored
- [ ] Manual testing shows labels can be queried by Sheet, item, or label_type
- [ ] Backend CLAUDE.md updated with Canonical Label patterns
